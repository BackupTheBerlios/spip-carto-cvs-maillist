<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Spip-carto-cvs] spipcarto/ecrire/js x_core_nn4.js,NONE,1.1 navTools.bak.js,NONE,1.1 x_dom_nn4.js,NONE,1.1 carto.js,NONE,1.1 graphTools.js,NONE,1.1 tree.js,NONE,1.1 x_event_nn4.js,NONE,1.1 navTools.js,NONE,1.1 Copie de navTools.js,NONE,1.1
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/spip-carto-cvs/2005-February/index.html" >
   <LINK REL="made" HREF="mailto:spip-carto-cvs%40lists.berlios.de?Subject=Re%3A%20%5BSpip-carto-cvs%5D%20spipcarto/ecrire/js%20x_core_nn4.js%2CNONE%2C1.1%20navTools.bak.js%2CNONE%2C1.1%20x_dom_nn4.js%2CNONE%2C1.1%20carto.js%2CNONE%2C1.1%20graphTools.js%2CNONE%2C1.1%20tree.js%2CNONE%2C1.1%20x_event_nn4.js%2CNONE%2C1.1%20navTools.js%2CNONE%2C1.1%20Copie%20de%20navTools.js%2CNONE%2C1.1&In-Reply-To=%3C200502202206.j1KM618Y026983%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000075.html">
   <LINK REL="Next"  HREF="000078.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Spip-carto-cvs] spipcarto/ecrire/js x_core_nn4.js,NONE,1.1 navTools.bak.js,NONE,1.1 x_dom_nn4.js,NONE,1.1 carto.js,NONE,1.1 graphTools.js,NONE,1.1 tree.js,NONE,1.1 x_event_nn4.js,NONE,1.1 navTools.js,NONE,1.1 Copie de navTools.js,NONE,1.1</H1>
    <B>stef at berlios.de</B> 
    <A HREF="mailto:spip-carto-cvs%40lists.berlios.de?Subject=Re%3A%20%5BSpip-carto-cvs%5D%20spipcarto/ecrire/js%20x_core_nn4.js%2CNONE%2C1.1%20navTools.bak.js%2CNONE%2C1.1%20x_dom_nn4.js%2CNONE%2C1.1%20carto.js%2CNONE%2C1.1%20graphTools.js%2CNONE%2C1.1%20tree.js%2CNONE%2C1.1%20x_event_nn4.js%2CNONE%2C1.1%20navTools.js%2CNONE%2C1.1%20Copie%20de%20navTools.js%2CNONE%2C1.1&In-Reply-To=%3C200502202206.j1KM618Y026983%40sheep.berlios.de%3E"
       TITLE="[Spip-carto-cvs] spipcarto/ecrire/js x_core_nn4.js,NONE,1.1 navTools.bak.js,NONE,1.1 x_dom_nn4.js,NONE,1.1 carto.js,NONE,1.1 graphTools.js,NONE,1.1 tree.js,NONE,1.1 x_event_nn4.js,NONE,1.1 navTools.js,NONE,1.1 Copie de navTools.js,NONE,1.1">stef at berlios.de
       </A><BR>
    <I>Sun Feb 20 23:06:01 CET 2005</I>
    <P><UL>
        <LI>Previous message: <A HREF="000075.html">[Spip-carto-cvs] CVSROOT modules,1.5,1.6
</A></li>
        <LI>Next message: <A HREF="000078.html">[Spip-carto-cvs] spipcarto/ecrire/lang ecrire_ar.php3,NONE,1.1
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#77">[ date ]</a>
              <a href="thread.html#77">[ thread ]</a>
              <a href="subject.html#77">[ subject ]</a>
              <a href="author.html#77">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Update of /cvsroot/spip-carto/spipcarto/ecrire/js
In directory sheep:/tmp/cvs-serv26976/ecrire/js

Added Files:
	x_core_nn4.js navTools.bak.js x_dom_nn4.js carto.js 
	graphTools.js tree.js x_event_nn4.js navTools.js 
	Copie de navTools.js 
Log Message:
proto1.3

--- NEW FILE: x_core_nn4.js ---
// x_core_nn4.js
// For NN4 use this file instead of x_core.js. xInclude() will do this for you automatically.

// X v3.15.1, Cross-Browser DHTML Library from Cross-Browser.com
// Copyright (c) 2002,2003,2004 Michael Foster (<A HREF="https://lists.berlios.de/mailman/listinfo/spip-carto-cvs">mike at cross-browser.com</A>)
// This library is distributed under the terms of the LGPL (gnu.org)

// Variables:
var xVersion='3.15.1',xNN4=false,xOp7=false,xOp5or6=false,xIE=false,xIE4Up=false,xIE4=false,xIE5=false,xUA=navigator.userAgent.toLowerCase();
if(window.opera){
  xOp7=(xUA.indexOf('opera 7')!=-1 || xUA.indexOf('opera/7')!=-1);
  if (!xOp7) xOp5or6=(xUA.indexOf('opera 5')!=-1 || xUA.indexOf('opera/5')!=-1 || xUA.indexOf('opera 6')!=-1 || xUA.indexOf('opera/6')!=-1);
}
else if (document.layers) {xNN4=true;}
else if (document.all) {
  xIE=xUA.indexOf('msie')!=-1;
  xIE4Up=xUA.indexOf('msie')!=-1 &amp;&amp; parseInt(navigator.appVersion)&gt;=4;
  xIE4=xUA.indexOf('msie 4')!=-1;
  xIE5=xUA.indexOf('msie 5')!=-1;
}
// Object:
function xGetElementById(e) {
  if(typeof(e)!='string') return e;
  if(document.getElementById) e=document.getElementById(e);
  else if(document.all) e=document.all[e];
  else if(document.layers) e=xLayer(e);
  else e=null;
  return e;
}
function xLayer(id,root) { // only for nn4
  var i,layer,found=null;
  if (!root) root=window;
  for(i=0; i&lt;root.document.layers.length; i++) {
    layer=root.document.layers[i];
    if(layer.id==id) return layer;
    if(layer.document.layers.length) found=xLayer(id,layer);
    if(found) return found;
  }
  return null;
}
function xParent(e,bNode){
  if (!(e=xGetElementById(e))) return null;
  var p=null;
  if (!bNode &amp;&amp; xDef(e.offsetParent)) p=e.offsetParent;
  else if (xDef(e.parentNode)) p=e.parentNode;
  else if (xDef(e.parentElement)) p=e.parentElement;
  else if (xDef(e.parentLayer)){if (e.parentLayer!=window) p=e.parentLayer;}
  return p;
}
function xDef() {
  for(var i=0; i&lt;arguments.length; ++i){if(typeof(arguments[i])=='undefined') return false;}
  return true;
}
function xStr(s) {
  return typeof(s)=='string';
}
function xNum(n) {
  return typeof(n)=='number';
}
function xInnerHtml(e, sHtml) {
  if(!(e=xGetElementById(e))) return '';
  if (xStr(e.innerHTML)) {
    if (xStr(sHtml)) e.innerHTML = sHtml;
    else return e.innerHTML;
  }
  else if (xNN4) {
    if (xStr(sHtml)) {
      if (sHtml=='') sHtml = ' ';
      e.document.open();
      e.document.write(sHtml);
      e.document.close();
    }
    else return '';
  }
}
// Appearance:
function xShow(e) {
  if(!(e=xGetElementById(e))) return;
  if(e.style &amp;&amp; xDef(e.style.visibility)) e.style.visibility='visible';
  else if(xDef(e.visibility)) e.visibility='show';
}
function xHide(e) {
  if(!(e=xGetElementById(e))) return;
  if(e.style &amp;&amp; xDef(e.style.visibility)) e.style.visibility='hidden';
  else if(xDef(e.visibility)) e.visibility='hide';
}
function xZIndex(e,uZ) {
  if(!(e=xGetElementById(e))) return 0;
  if(e.style &amp;&amp; xDef(e.style.zIndex)) {
    if(xNum(uZ)) e.style.zIndex=uZ;
    uZ=parseInt(e.style.zIndex);
  }
  else if(xDef(e.zIndex)) {
    if(xNum(uZ)) e.zIndex=uZ;
    uZ=e.zIndex;
  }
  return uZ;
}
function xColor(e,sColor) {
  if(!(e=xGetElementById(e))) return '';
  var c='';
  if(e.style &amp;&amp; xDef(e.style.color)) {
    if(xStr(sColor)) e.style.color=sColor;
    c=e.style.color;
  }
  return c;
}
function xBackground(e,sColor,sImage) {
  if(!(e=xGetElementById(e))) return '';
  var bg='';
  if(e.style) {
    if(xStr(sColor)) {
      if(!xOp5or6) e.style.backgroundColor=sColor;
      else e.style.background=sColor;
    }
    if(xStr(sImage)) e.style.backgroundImage=(sImage!='')? 'url('+sImage+')' : null;
    if(!xOp5or6) bg=e.style.backgroundColor;
    else bg=e.style.background;
  }
  else if(xDef(e.bgColor)) {
    if(xStr(sColor)) e.bgColor=sColor;
    bg=e.bgColor;
    if(xStr(sImage)) e.background.src=sImage;
  }
  return bg;
}
// Position:
function xMoveTo(e,iX,iY) {
  xLeft(e,iX);
  xTop(e,iY);
}
function xLeft(e,iX) {
  if(!(e=xGetElementById(e))) return 0;
  var css=xDef(e.style);
  if (css &amp;&amp; xStr(e.style.left)) {
    if(xNum(iX)) e.style.left=iX+'px';
    else {
      iX=parseInt(e.style.left);
      if(isNaN(iX)) iX=0;
    }
  }
  else if(css &amp;&amp; xDef(e.style.pixelLeft)) {
    if(xNum(iX)) e.style.pixelLeft=iX;
    else iX=e.style.pixelLeft;
  }
  else if(xDef(e.left)) {
    if(xNum(iX)) e.left=iX;
    else iX=e.left;
  }
  return iX;
}
function xTop(e,iY) {
  if(!(e=xGetElementById(e))) return 0;
  var css=xDef(e.style);
  if(css &amp;&amp; xStr(e.style.top)) {
    if(xNum(iY)) e.style.top=iY+'px';
    else {
      iY=parseInt(e.style.top);
      if(isNaN(iY)) iY=0;
    }
  }
  else if(css &amp;&amp; xDef(e.style.pixelTop)) {
    if(xNum(iY)) e.style.pixelTop=iY;
    else iY=e.style.pixelTop;
  }
  else if(xDef(e.top)) {
    if(xNum(iY)) e.top=iY;
    else iY=e.top;
  }
  return iY;
}
function xPageX(e) {
  if (!(e=xGetElementById(e))) return 0;
  if (xDef(e.pageX)) return e.pageX;
  var x = 0;
  while (e) {
    if (xDef(e.offsetLeft)) x += e.offsetLeft;
    e = xDef(e.offsetParent) ? e.offsetParent : null;
  }
  return x;
}
function xPageY(e) {
  if (!(e=xGetElementById(e))) return 0;
  if (xDef(e.pageY)) return e.pageY;
  var y = 0;
  while (e) {
    if (xDef(e.offsetTop)) y += e.offsetTop;
    e = xDef(e.offsetParent) ? e.offsetParent : null;
  }
//  if (xOp7) return y - document.body.offsetTop; // v3.14, temporary hack for opera bug 130324
  return y;
}
function xOffsetLeft(e) {
  if (!(e=xGetElementById(e))) return 0;
  if (xDef(e.offsetLeft)) return e.offsetLeft;
  else return xPageX(e) - xPageX(xParent(e));
}
function xOffsetTop(e) {
  if (!(e=xGetElementById(e))) return 0;
  if (xDef(e.offsetTop)) return e.offsetTop;
  else return xPageY(e) - xPageY(xParent(e));
}
function xScrollLeft(e) {
  var offset=0;
  if (!(e=xGetElementById(e))) {
    if(xDef(window.pageXOffset)) offset=window.pageXOffset;
    else if(document.documentElement &amp;&amp; document.documentElement.scrollLeft) offset=document.documentElement.scrollLeft;
    else if(document.body &amp;&amp; xDef(document.body.scrollLeft)) offset=document.body.scrollLeft;
  }
  else { if (xNum(e.scrollLeft)) offset = e.scrollLeft; }
  return offset;
}
function xScrollTop(e) {
  var offset=0;
  if (!(e=xGetElementById(e))) {
    if(xDef(window.pageYOffset)) offset=window.pageYOffset;
    else if(document.documentElement &amp;&amp; document.documentElement.scrollTop) offset=document.documentElement.scrollTop;
    else if(document.body &amp;&amp; xDef(document.body.scrollTop)) offset=document.body.scrollTop;
  }
  else { if (xNum(e.scrollTop)) offset = e.scrollTop; }
  return offset;
}
function xHasPoint(ele, iLeft, iTop, iClpT, iClpR, iClpB, iClpL) {
  if (!xNum(iClpT)){iClpT=iClpR=iClpB=iClpL=0;}
  else if (!xNum(iClpR)){iClpR=iClpB=iClpL=iClpT;}
  else if (!xNum(iClpB)){iClpL=iClpR; iClpB=iClpT;}
  var thisX = xPageX(ele), thisY = xPageY(ele);
  return (iLeft &gt;= thisX + iClpL &amp;&amp; iLeft &lt;= thisX + xWidth(ele) - iClpR &amp;&amp;
          iTop &gt;=thisY + iClpT &amp;&amp; iTop &lt;= thisY + xHeight(ele) - iClpB );
}
// Size:
function xResizeTo(e,uW,uH) {
  xWidth(e,uW);
  xHeight(e,uH);
}
function xWidth(e,uW) {
  if(!(e=xGetElementById(e))) return 0;
  if (xNum(uW)) { // v3.13.1
    if (uW&lt;0) uW = 0;
    else uW=Math.round(uW);
  }
  else uW=0;
  var css=xDef(e.style);
  if(css &amp;&amp; xDef(e.offsetWidth) &amp;&amp; xStr(e.style.width)) {
    if(uW) xSetCW(e, uW);
    uW=e.offsetWidth;
  }
  else if(css &amp;&amp; xDef(e.style.pixelWidth)) {
    if(uW) e.style.pixelWidth=uW;
    uW=e.style.pixelWidth;
  }
  else if(xDef(e.clip) &amp;&amp; xDef(e.clip.right)) {
    if(uW) e.clip.right=uW;
    uW=e.clip.right;
  }
  return uW;
}
function xHeight(e,uH) {
  if(!(e=xGetElementById(e))) return 0;
  if (xNum(uH)) { // v3.13.1
    if (uH&lt;0) uH = 0;
    else uH=Math.round(uH);
  }
  else uH=0;
  var css=xDef(e.style);
  if(css &amp;&amp; xDef(e.offsetHeight) &amp;&amp; xStr(e.style.height)) {
    if(uH) xSetCH(e, uH);
    uH=e.offsetHeight;
  }
  else if(css &amp;&amp; xDef(e.style.pixelHeight)) {
    if(uH) e.style.pixelHeight=uH;
    uH=e.style.pixelHeight;
  }
  else if(xDef(e.clip) &amp;&amp; xDef(e.clip.bottom)) {
    if(uH) e.clip.bottom=uH;
    uH=e.clip.bottom;
  }
  return uH;
}
function xGetCS(ele,sP){return parseInt(document.defaultView.getComputedStyle(ele,'').getPropertyValue(sP));}
function xSetCW(ele,uW){
  var pl=0,pr=0,bl=0,br=0;
  if(xDef(document.defaultView) &amp;&amp; xDef(document.defaultView.getComputedStyle)){
    pl=xGetCS(ele,'padding-left');
    pr=xGetCS(ele,'padding-right');
    bl=xGetCS(ele,'border-left-width');
    br=xGetCS(ele,'border-right-width');
  }
  else if(xDef(ele.currentStyle,document.compatMode)){
    if(document.compatMode=='CSS1Compat'){
      pl=parseInt(ele.currentStyle.paddingLeft);
      pr=parseInt(ele.currentStyle.paddingRight);
      bl=parseInt(ele.currentStyle.borderLeftWidth);
      br=parseInt(ele.currentStyle.borderRightWidth);
    }
  }
  else if(xDef(ele.offsetWidth,ele.style.width)){ // ?
    ele.style.width=uW+'px';
    //pl=ele.offsetWidth-uW;  // bug in IE4
  }
  if(isNaN(pl)) pl=0; if(isNaN(pr)) pr=0; if(isNaN(bl)) bl=0; if(isNaN(br)) br=0;
  var cssW=uW-(pl+pr+bl+br);
  if(isNaN(cssW)||cssW&lt;0) return;
  else ele.style.width=cssW+'px';
}
function xSetCH(ele,uH){
  var pt=0,pb=0,bt=0,bb=0;
  if(xDef(document.defaultView) &amp;&amp; xDef(document.defaultView.getComputedStyle)){
    pt=xGetCS(ele,'padding-top');
    pb=xGetCS(ele,'padding-bottom');
    bt=xGetCS(ele,'border-top-width');
    bb=xGetCS(ele,'border-bottom-width');
  }
  else if(xDef(ele.currentStyle,document.compatMode)){
    if(document.compatMode=='CSS1Compat'){
      pt=parseInt(ele.currentStyle.paddingTop);
      pb=parseInt(ele.currentStyle.paddingBottom);
      bt=parseInt(ele.currentStyle.borderTopWidth);
      bb=parseInt(ele.currentStyle.borderBottomWidth);
    }
  }
  else if(xDef(ele.offsetHeight,ele.style.height)){ // ?
    ele.style.height=uH+'px';
    //pt=ele.offsetHeight-uH;  // bug in IE4
  }
  if(isNaN(pt)) pt=0; if(isNaN(pb)) pb=0; if(isNaN(bt)) bt=0; if(isNaN(bb)) bb=0;
  var cssH=uH-(pt+pb+bt+bb);
  if(isNaN(cssH)||cssH&lt;0) return;
  else ele.style.height=cssH+'px';
}
function xClip(e,iTop,iRight,iBottom,iLeft) {
  if(!(e=xGetElementById(e))) return;
  if(e.style) {
    if (xNum(iLeft)) e.style.clip='rect('+iTop+'px '+iRight+'px '+iBottom+'px '+iLeft+'px)';
    else e.style.clip='rect(0 '+parseInt(e.style.width)+'px '+parseInt(e.style.height)+'px 0)';
  }
  else if(e.clip) {
    if (xNum(iLeft)) { e.clip.top=iTop; e.clip.right=iRight; e.clip.bottom=iBottom; e.clip.left=iLeft; }
    else { e.clip.top=0; e.clip.right=xWidth(e); e.clip.bottom=xHeight(e); e.clip.left=0; }
  }
}
// Window:
function xClientWidth() {
  var w=0;
  if(xOp5or6) w=window.innerWidth;
  else if(!window.opera &amp;&amp; document.documentElement &amp;&amp; document.documentElement.clientWidth) // v3.12
    w=document.documentElement.clientWidth;
  else if(document.body &amp;&amp; document.body.clientWidth)
    w=document.body.clientWidth;
  else if(xDef(window.innerWidth,window.innerHeight,document.height)) {
    w=window.innerWidth;
    if(document.height&gt;window.innerHeight) w-=16;
  }
  return w;
}
function xClientHeight() {
  var h=0;
  if(xOp5or6) h=window.innerHeight;
  else if(!window.opera &amp;&amp; document.documentElement &amp;&amp; document.documentElement.clientHeight) // v3.12
    h=document.documentElement.clientHeight;
  else if(document.body &amp;&amp; document.body.clientHeight)
    h=document.body.clientHeight;
  else if(xDef(window.innerWidth,window.innerHeight,document.width)) {
    h=window.innerHeight;
    if(document.width&gt;window.innerWidth) h-=16;
  }
  return h;
}
// end x_core_nn4.js

--- NEW FILE: navTools.bak.js ---
// Global variables

// dhtmlBox constructor
function dhtmlBox() {
  this.anchor = xGetElementById(&quot;mapAnchorDiv&quot;);
  this.target = xGetElementById(&quot;mainDHTMLDiv&quot;);
  this.image = xGetElementById(&quot;mapImageDiv&quot;);
  this.canvas = xGetElementById(&quot;myCanvasDiv&quot;);
  this.canvas2 = xGetElementById(&quot;myCanvas2Div&quot;);
  this.displayContainer = xGetElementById(&quot;diplayContainerDiv&quot;);
  this.displayCoords = xGetElementById(&quot;displayCoordsDiv&quot;);
  this.displayMeasure = xGetElementById(&quot;displayMeasureDiv&quot;);

  this.x1 = this.y1 = this.x2 = this.y2 = -1;
  this.drag = false;
  this.isActive = false;
  this.dblClick = false;
  this.keyEscape = false;
}

// method prototypes
function dhtmlBox_initialize() {
  jg = new jsGraphics(this.canvas.id); // a drawing canvas for the lines and points
  jg2 = new jsGraphics(this.canvas2.id); // a drawing canvas for the last moving vertex

  // make the previous tool selected the current one
  for (var i =0; i &lt; myform.tool.length; i++) {
    if (myform.tool[i].checked) {
      dhtmlBox.changeTool(myform.tool[i].value);
    }
  }
  
  // HACK FOR selection tool: find a better solution !!
  if (myform.tool.length &gt;= 5 &amp;&amp; myform.tool[4].checked) {
     dhtmlBox.changeTool('query');
  }
  
  this.target.style.zIndex = 1000;

  this.width = xWidth(this.anchor);
  this.height = xHeight(this.anchor);

  xResizeTo(this.image,this.width,this.height);
  xResizeTo(this.target,this.width,this.height);
  xResizeTo(this.canvas,this.width,this.height);
  xResizeTo(this.canvas2,this.width,this.height);
  xWidth(this.displayContainer,this.width);

  xMoveTo(this.image,xPageX(this.anchor),xPageY(this.anchor));
  xMoveTo(this.target,xPageX(this.anchor),xPageY(this.anchor));
  xMoveTo(this.canvas,xPageX(this.anchor),xPageY(this.anchor));
  xMoveTo(this.canvas2,xPageX(this.anchor),xPageY(this.anchor));
  xShow(this.image);

  if (this.dispPos == &quot;top&quot;) this.dispPos = -13;
  else if (this.dispPos == &quot;bottom&quot;) this.dispPos = this.height;
  else this.dispPos = 0;
  xMoveTo(this.displayContainer,xPageX(this.anchor),xPageY(this.anchor) + this.dispPos);

  xClip(this.target,0,this.width,this.height,0);
}


function dhtmlBox_changetool(tool) {// the mouse events are managed in this function according to the mapping tool selected
  myform.tool.value = tool;
  this.currentTool = tool.toLowerCase();

  // clear the drawing canvas
  jg.clear();

  xRemoveEventListener(this.target,'mousedown',this.domousedown);
  xRemoveEventListener(this.target,'mouseup',this.domouseup);
  xRemoveEventListener(this.target,'mousemove',this.domousemove);
  xRemoveEventListener(this.target,'mouseout',this.domouseout);
  xRemoveEventListener(this.target, 'dblclick', this.dodblclick);
  
  xAddEventListener(this.target,'mousedown',this.domousedown);
  xAddEventListener(this.target,'mouseup',this.domouseup);
  xAddEventListener(this.target,'mousemove',this.domousemove);
  xAddEventListener(this.target,'mouseout',this.domouseout);

  xAddEventListener(document,'keydown',this.dokeydown);

  if (this.currentTool == 'distance' || this.currentTool == 'surface' || this.currentTool == 'polygon' || this.currentTool == 'line') {
    this.isActive = false;
    this.distance = 0;
    this.displayCoords.innerHTML = '';
    this.displayMeasure.innerHTML = '';
    xAddEventListener(this.target,'dblclick', this.dodblclick);
  }

  // cursor style
  if (this.currentTool == 'zoom_in' || this.currentTool == 'zoom_out' || this.currentTool == 'distance' || this.currentTool == 'surface' || this.currentTool == 'polygon' || this.currentTool == 'line') {
    if (this.target.style) this.target.style.cursor = &quot;crosshair&quot;;
  } else if (this.currentTool == 'pan') {
    if (this.target.style) this.target.style.cursor = &quot;move&quot;;
  } else if (this.currentTool == 'query') {
    if (this.target.style) this.target.style.cursor = &quot;help&quot;;
  }
  jg.paint();
}

function dhtmlBox_mousedown(evt) {
  var e = new xEvent(evt);
  
  if (!(xUA.indexOf('mac_')!=-1 &amp;&amp; xUA.indexOf('msie')!=-1) &amp;&amp; evt.button == 2) { //right clic
    dhtmlBox.rightclic = true;
  } else {
    dhtmlBox.rightclic = false;

    dhtmlBox.x1 = dhtmlBox.x2 = e.offsetX;
    dhtmlBox.y1 = dhtmlBox.y2 = e.offsetY;
	

    if (dhtmlBox.currentTool == &quot;zoom_out&quot;) {
      jg.clear();  // if page not reloaded automaticaly, previous crosses are deleted
    }

    if (!dhtmlBox.isActive &amp;&amp; (dhtmlBox.currentTool == 'distance' || dhtmlBox.currentTool == 'surface' || dhtmlBox.currentTool == 'polygon'  || dhtmlBox.currentTool == 'line')) { //init
      jg.clear();
      //jg2.clear();
      dhtmlBox.cnv_clicks = 0;
      dhtmlBox.draw_x = new Array();
      dhtmlBox.draw_y = new Array();
      dhtmlBox.Xpoints = new Array();
      dhtmlBox.Ypoints = new Array();
      dhtmlBox.distance = 0;
      dhtmlBox.isActive = true;
	  dhtmlBox.dblClick = false;
      dhtmlBox.keyEscape = false;
    }
  }
  if (dhtmlBox.currentTool == 'polygon'  || dhtmlBox.currentTool == 'line') {
    dhtmlBox.drag = false; // to provide the curves draw
  } else {
	dhtmlBox.drag = true; // the mouse is down
  }
}

function dhtmlBox_mousemove(evt) {
  var e = new xEvent(evt);

  //show the coords display
  xShow(dhtmlBox.displayContainer);

  if(dhtmlBox.drag) { //the mouse is down
    dhtmlBox.x2 = e.offsetX;
    dhtmlBox.y2 = e.offsetY;
    if(dhtmlBox.currentTool == 'zoom_out') { // only one click events
      jg.clear();
      dhtmlBox.x1 = dhtmlBox.x2;
      dhtmlBox.y1 = dhtmlBox.y2;
    }
    dhtmlBox.paint();
  }
  else if ((dhtmlBox.currentTool == 'distance' || dhtmlBox.currentTool == 'surface' || dhtmlBox.currentTool == 'polygon'  || dhtmlBox.currentTool == 'line') &amp;&amp; dhtmlBox.isActive == true) {
      dhtmlBox.x2 = e.offsetX;
      dhtmlBox.y2 = e.offsetY;
      dhtmlBox.lastLinePaint(); // the last line is drawn while moving
  }
    // display the coordinates
    dhtmlBox.displayCoords.innerHTML = dhtmlBox.coord_msg + Math.round((e.offsetX * dhtmlBox.pixel_size) + dhtmlBox.boxx)  +&quot; / &quot;+ Math.round(((dhtmlBox.mapHeight - e.offsetY) * dhtmlBox.pixel_size) + dhtmlBox.boxy);
}

function dhtmlBox_mouseup(evt) {
  var e = new xEvent(evt);

  if (dhtmlBox.rightclic == true) {
    jg2.clear();
  } else {

    dhtmlBox.drag = false; //the mouse is now up

    dhtmlBox.x2 = e.offsetX;
    dhtmlBox.y2 = e.offsetY;

    //the box is too small
    if(((Math.abs(dhtmlBox.x1-dhtmlBox.x2) &lt;= dhtmlBox.jitter) || (Math.abs(dhtmlBox.y1-dhtmlBox.y2) &lt;= dhtmlBox.jitter)) &amp;&amp; dhtmlBox.currentTool == 'zoom_in') {
      dhtmlBox.x2 = dhtmlBox.x1 = Math.abs(dhtmlBox.x1-dhtmlBox.x2) /2 + Math.min(dhtmlBox.x1, dhtmlBox.x2); //zoom to center of the box
      dhtmlBox.y2 = dhtmlBox.y1 = Math.abs(dhtmlBox.y1-dhtmlBox.y2) /2 + Math.min(dhtmlBox.y1, dhtmlBox.y2);;
    }

    // submit the form with the values
    if (dhtmlBox.currentTool == 'zoom_in' || dhtmlBox.currentTool == 'zoom_out' || dhtmlBox.currentTool == 'query') {
      dhtmlBox.removeEventsWait();
      myform.selection_type.value = &quot;rectangle&quot;;
      myform.selection_coords.value = dhtmlBox.x1+&quot;,&quot;+dhtmlBox.y1+&quot;;&quot;+dhtmlBox.x2+&quot;,&quot;+dhtmlBox.y2
	  xShow(dhtmlBox.anchor);
      myform.submit();
    }
    else if (dhtmlBox.currentTool == 'pan') {
      myform.selection_type.value = &quot;point&quot;
      // pan or simple pan click
      if (dhtmlBox.x2 == dhtmlBox.x1 &amp;&amp; dhtmlBox.y2 == dhtmlBox.y1) { //simple click
        var x = dhtmlBox.x2
        var y = dhtmlBox.y2
        myform.selection_coords.value = x+&quot;,&quot;+y
      } else {// pan
        //new center coordinates
        var x = dhtmlBox.width/2 - (dhtmlBox.x2 - dhtmlBox.x1)
        var y = dhtmlBox.height/2 - (dhtmlBox.y2 - dhtmlBox.y1)
        myform.selection_coords.value = x+&quot;,&quot;+y
      }
	  xShow(dhtmlBox.anchor);
      myform.submit();
    } else if (dhtmlBox.currentTool == 'surface' || dhtmlBox.currentTool == 'polygon') {
		// polygon closed by click on the first point
		if (Math.abs(dhtmlBox.x2 - dhtmlBox.draw_x[1]) &lt;= dhtmlBox.jitter &amp;&amp; Math.abs(dhtmlBox.y2 - dhtmlBox.draw_y[1]) &lt;= dhtmlBox.jitter &amp;&amp; dhtmlBox.draw_x.length &gt; 2) {
			dhtmlBox.keyEscape = true;
			dhtmlBox.isActive = false;
			jg2.clear();
		}
	}
    dhtmlBox.paint();
  }
}

function dhtmlBox_mouseout(evt) {
  var e = new xEvent(evt);

  xHide(dhtmlBox.displayContainer);
  jg2.clear();
}

function dhtmlBox_dblclick(evt) {
  var e = new xEvent(evt);
  dhtmlBox.dblClick = true;
  dhtmlBox.isActive = false;

  jg2.clear();
  dhtmlBox.paint();
}

function dhtmlBox_keydown(evt) { // 
  evt = (evt) ? evt : ((event) ? event : null);
  dhtmlBox = dhtmlBox;
  if (evt.keyCode == '27' &amp;&amp; (dhtmlBox.currentTool == 'distance' || dhtmlBox.currentTool == 'surface' || dhtmlBox.currentTool == 'polygon'  || dhtmlBox.currentTool == 'line')) {
    dhtmlBox.keyEscape = true;
    dhtmlBox.isActive = false;
    jg2.clear();
    dhtmlBox.paint();
  }
}

function dhtmlBox_paint() { // draws alternatively boxes, lines, polylines, crosses, or pan the map
  var x, y, w, h;

  x = Math.min(this.x1, this.x2);
  y = Math.min(this.y1, this.y2);

  if (this.currentTool == 'zoom_out') { //draws only a cross
      jg.drawLineW(x-this.cursorsize,y - this.thickness /2,this.cursorsize * 2);
      jg.drawLineH(x - this.thickness /2,y-this.cursorsize ,this.cursorsize * 2);
      jg.paint();
  }

  else if (this.currentTool == 'zoom_in' || this.currentTool == 'query') {
    if(this.x1==this.x2 &amp;&amp; this.y1==this.y2) {
        jg.clear();
        jg.drawLineW(x-this.cursorsize,y - this.thickness /2,this.cursorsize * 2);
        jg.drawLineH(x - this.thickness /2,y-this.cursorsize ,this.cursorsize * 2);
        jg.paint();

    } else {
      w = Math.abs(this.x1-this.x2);
      h = Math.abs(this.y1-this.y2);
      jg.clear();
          jg.drawRect(x,y,w,h,this.thickness);
      jg.paint();
    }
  }
  else if (this.currentTool == 'pan') {
    var dx,dy

    dx = this.x2 - this.x1;
    dy = this.y2 - this.y1;

    xMoveTo(this.image,dx + xPageX(this.anchor),dy + xPageY(this.anchor));
    xClip(this.image,(dy&lt;0)? Math.abs(dy):0,(dx&gt;0)? this.width - dx : this.width,(dy&gt;0)? this.height-dy:this.height,(dx&lt;0)? Math.abs(dx):0);
    //xResizeTo(this.image,(dy&lt;0)? Math.abs(dy):0,(dx&gt;0)? this.width - dx : this.width,(dy&gt;0)? this.height-dy:this.height,(dx&lt;0)? Math.abs(dx):0);
  }

  else if (this.currentTool == 'distance' || this.currentTool == 'line') {
    if (!this.keyEscape) { // Escape key is pressed
      ++this.cnv_clicks;
      this.draw_x[this.cnv_clicks] = this.x2;
      this.draw_y[this.cnv_clicks] = this.y2;
    }
    this.Xpoints[this.cnv_clicks - 1] = this.draw_x[this.cnv_clicks];
    this.Ypoints[this.cnv_clicks - 1] = this.draw_y[this.cnv_clicks];
    if (xUA.indexOf('mac_')!=-1 &amp;&amp; xUA.indexOf('msie')!=-1) { // IE/Mac specificity
      jg.clear();
      jg.drawPolylinePts(this.Xpoints,this.Ypoints, this.d2pts);
    }
    else {
        jg.drawLinePts(this.draw_x[this.cnv_clicks],this.draw_y[this.cnv_clicks],this.draw_x[this.cnv_clicks - 1],this.draw_y[this.cnv_clicks - 1],this.d2pts);
    }
	if (this.currentTool == 'distance') { //Calculate the distance and display it
	  if (this.cnv_clicks &gt; 1 &amp;&amp; !this.keyEscape) {
        // distance calculation
        this.dist_x = (this.draw_x[this.cnv_clicks] - this.draw_x[this.cnv_clicks - 1]) * this.pixel_size;
        this.dist_y = (this.draw_y[this.cnv_clicks] - this.draw_y[this.cnv_clicks - 1]) * this.pixel_size;
        this.distance += Math.sqrt(this.dist_x * this.dist_x + this.dist_y * this.dist_y);
      }
      if (this.dist_unit == ' m.') this.distance = Math.round(this.distance);
      else if (this.dist_unit == ' km.') this.distance = Math.round(this.distance*100)/100;
      this.displayMeasure.innerHTML = this.dist_msg + this.distance.toString() + this.dist_unit;
	} else if (this.currentTool == 'line' &amp;&amp; !this.isActive) { // submit the form
		var coords = new String();
		for (i = 0; i &lt; this.Xpoints.length; i++) {
			coords += this.Xpoints[i] +&quot;,&quot; + this.Ypoints[i] + &quot;;&quot;;
		}
		myform.selection_type.value = 'line';
		myform.selection_coords.value = coords.substring(0,coords.length - 1);
		xShow(this.anchor);
		myform.submit();
	}
    jg.paint();
  }
  else if (this.currentTool == 'surface' || this.currentTool == 'polygon') {
    if (!this.keyEscape) { // Escape key is pressed
      ++this.cnv_clicks;
      this.draw_x[this.cnv_clicks] = this.x2;
      this.draw_y[this.cnv_clicks] = this.y2;
    }
    this.Xpoints[this.cnv_clicks - 1] = this.draw_x[this.cnv_clicks];
    this.Ypoints[this.cnv_clicks - 1] = this.draw_y[this.cnv_clicks];
    if (xUA.indexOf('mac_')!=-1 &amp;&amp; xUA.indexOf('msie')!=-1) { // IE/Mac specificity
      if (!this.isActive) { // close the polygon
        this.Xpoints[this.cnv_clicks] = this.draw_x[1];
        this.Ypoints[this.cnv_clicks] = this.draw_y[1];
      }
      jg.clear();
      jg.drawPolylinePts(this.Xpoints,this.Ypoints, this.d2pts);
    }
    else {
      jg.drawLinePts(this.draw_x[this.cnv_clicks],this.draw_y[this.cnv_clicks],this.draw_x[this.cnv_clicks - 1],this.draw_y[this.cnv_clicks - 1],this.d2pts);
      if (!this.isActive) { // close the polygon
        jg.drawLinePts(this.draw_x[this.cnv_clicks],this.draw_y[this.cnv_clicks],this.draw_x[1],this.draw_y[1],this.d2pts);		
      }
    }

	if (this.currentTool == 'surface') { // calculate the surface and display it
	  if (this.cnv_clicks &gt; 1  &amp;&amp; !this.keyEscape) {
        //surface calculation
        var i = 0;
        this.distance = 0;
        while (i &lt; this.cnv_clicks - 1) {
          this.distance += this.Xpoints[i] * this.Ypoints[i+1] - this.Xpoints[i+1] * this.Ypoints[i];
          ++i;
        }
        this.distance += this.Xpoints[this.cnv_clicks -1] * this.Ypoints[0] - this.Xpoints[0] * this.Ypoints[this.cnv_clicks -1];
        var pix_surf = this.pixel_size * this.pixel_size;
        this.distance = Math.abs(this.distance.toString()) / 2 * pix_surf;
	  }
      if (this.surf_unit == ' m2.') this.distance = Math.round(this.distance);
      else if (this.surf_unit == ' km2.') this.distance = Math.round(this.distance*10000)/10000;
      this.displayMeasure.innerHTML = this.surf_msg+ this.distance +this.surf_unit;
    } else if (this.currentTool == 'polygon' &amp;&amp; !this.isActive) { // draw the closed polygon and submit form
		jg.paint();
		var coords = new String();
		for (i = 0; i &lt; this.Xpoints.length; i++) {
			coords += this.Xpoints[i] +&quot;,&quot; + this.Ypoints[i] + &quot;;&quot;;
		}
		myform.selection_type.value = 'polygon';
		myform.selection_coords.value = coords.substring(0,coords.length - 1);
		xShow(this.anchor);
		myform.submit();
	}
	jg.paint();
  }
}


function dhtmlBox_lastLinePaint() {

  var x2 = this.x2;
  var y2 = this.y2;
  var x = this.draw_x[this.cnv_clicks];
  var y = this.draw_y[this.cnv_clicks];
  var x0 = this.draw_x[1];
  var y0 = this.draw_y[1];

  if (xIE || xUA.indexOf('mac')!=-1) { //use the drawing API
    jg2.clear();
    jg2.drawLinePts(x2,y2,x,y,this.d2pts); //draw the last vertex
    if (this.currentTool == &quot;surface&quot; || this.currentTool == &quot;polygon&quot;) {
      jg2.drawLinePts(x2,y2,x0,y0,this.d2pts); // also draw the line to close the polygon
    }
    jg2.paint();
  }
  else { //doesn't use the drawing API
    if (this.canvas2.innerHTML == '') { // create the DIVs if doesn't exist
      for (var i=0; i&lt; this.nbPts * 2; i++) {
        this[&quot;vertexPt&quot;+i] = xCreateElement('div');
        xAppendChild(this.canvas2,this[&quot;vertexPt&quot;+i],200);
        this[&quot;vertexPt&quot;+i].className = &quot;point&quot;;
        xHide(this[&quot;vertexPt&quot;+i]);
        if (this[&quot;vertexPt&quot;+i].style) this[&quot;vertexPt&quot;+i].style.position = &quot;absolute&quot;;
      }
    }
    var dx = x2 - x;
    var dy = y2 - y;
    for (var i=0;i&lt;this.nbPts;i++) {
      var a = this[&quot;vertexPt&quot;+i];
      xMoveTo(a,x + dx *i/ this.nbPts,y + dy *i/ this.nbPts);
      xShow(a);
    }
    if (this.currentTool == &quot;surface&quot; || this.currentTool == &quot;polygon&quot;) {
      var dx0 = x2 - x0;
      var dy0 = y2 - y0;
      for (var i=this.nbPts;i&lt;this.nbPts * 2;i++) {
        var a = this[&quot;vertexPt&quot;+i];
        xMoveTo(a,x0 + dx0 * (i-this.nbPts)/this.nbPts,y0 + dy0 * (i-this.nbPts) / this.nbPts);
        xShow(a);
      }
    }
  }
}



new dhtmlBox(0);

dhtmlBox.prototype.initialize = dhtmlBox_initialize; // create instance method
dhtmlBox.prototype.domousedown = dhtmlBox_mousedown;
dhtmlBox.prototype.domousemove = dhtmlBox_mousemove;
dhtmlBox.prototype.domouseup = dhtmlBox_mouseup;
dhtmlBox.prototype.domouseout = dhtmlBox_mouseout;
dhtmlBox.prototype.dodblclick = dhtmlBox_dblclick;
dhtmlBox.prototype.dokeydown = dhtmlBox_keydown;
dhtmlBox.prototype.paint = dhtmlBox_paint;
dhtmlBox.prototype.lastLinePaint = dhtmlBox_lastLinePaint; // draw the last straight vertex for the measure tool
dhtmlBox.prototype.changeTool = dhtmlBox_changetool;
dhtmlBox.prototype.removeEventsWait = dhtmlBox_removeEventsWait;

/*
function changeTool(dhtmlBox,tool) {
  dhtmlBox.changetool(tool);
}
*/

function dhtmlBox_removeEventsWait() {
   xRemoveEventListener(this.target, 'mousemove', this.domousemove);
   if (this.target.style) this.target.style.cursor = &quot;wait&quot;;
}

--- NEW FILE: x_dom_nn4.js ---
// x_dom_nn4.js, X v3.15.2, Cross-Browser.com DHTML Library
// Copyright (c) 2004 Michael Foster, Licensed LGPL (gnu.org)

// Returns a new Element object. For NN4, returns a new Object object.

//Modified by Pierre GIRAUD 
function xCreateElement(sTag)
{
  var ele=null;
  if (document.createElement) ele = document.createElement(sTag);
  else if (xNN4) ele = new Object();
  return ele;
}
function xAppendChild(oParent, oChild, nn4Width) // returns oChild
{
  var ele=null;
  if (oParent &amp;&amp; oParent.appendChild) ele = oParent.appendChild(oChild);
  else if (xNN4) {
    if (typeof(oChild)=='object') delete oChild;
    if (!oParent || oParent.id.indexOf('_layer')==-1) {
      oParent = window;
      if (!nn4Width) nn4Width = xClientWidth();
    }
    else if (!nn4Width) nn4Width = xWidth(oParent);
    ele = new Layer(nn4Width, oParent);
  }
  return ele;
}

--- NEW FILE: carto.js ---
function FormItemSelected() {
  document.carto_form.submit();
}
  
function CheckRadio(theIndex) {
  document.carto_form.tool[theIndex].checked = true;
}

--- NEW FILE: graphTools.js ---
/*
graphTools.js

javascript functions to create and draw lines and points
for map navigation tool (zoom box, distance and surface measurement)

Part of this code was previously found from wz_jsgraphics.js (<A HREF="http://www.walterzorn.com">http://www.walterzorn.com</A>)
and hardly adapted

Copyright 2004 Pierre GIRAUD
<A HREF="http://www.camptocamp.com">http://www.camptocamp.com</A>
*/

var jg_ihtm, jg_ie, jg_fast, jg_dom, jg_moz,
jg_n4 = (document.layers &amp;&amp; typeof document.classes != &quot;undefined&quot;);


function chkDHTM(x, i)
{
	x = document.body || null;
	jg_ie = x &amp;&amp; typeof x.insertAdjacentHTML != &quot;undefined&quot;;
	jg_dom = (x &amp;&amp; !jg_ie &amp;&amp;
		typeof x.appendChild != &quot;undefined&quot; &amp;&amp;
		typeof document.createRange != &quot;undefined&quot; &amp;&amp;
		typeof (i = document.createRange()).setStartBefore != &quot;undefined&quot; &amp;&amp;
		typeof i.createContextualFragment != &quot;undefined&quot;);
	jg_ihtm = !jg_ie &amp;&amp; !jg_dom &amp;&amp; x &amp;&amp; typeof x.innerHTML != &quot;undefined&quot;;
	jg_fast = jg_ie &amp;&amp; document.all &amp;&amp; !window.opera;
	jg_moz = jg_dom &amp;&amp; typeof x.style.MozOpacity != &quot;undefined&quot;;
}

function pntDoc()
{
	this.wnd.document.write(this.htm);
	this.htm = '';
}


function pntCnvDom()
{
	var x = document.createRange();
	x.setStartBefore(this.cnv);
	x = x.createContextualFragment(this.htm);
	this.cnv.appendChild(x);
	this.htm = '';
}


function pntCnvIe()
{
	this.cnv.insertAdjacentHTML(&quot;beforeEnd&quot;,this.htm);
	this.htm = '';
}

function pntCnv()
{
	this.htm = '';
}


function mkDivPt(x,y)
{
	this.htm += '&lt;div class=&quot;point&quot; style=&quot;left:'+x+'px;top:'+y+'px&quot;&gt;&lt;/div&gt;';
	//this.htm += '&lt;div style=&quot;position:absolute;left:'+x+';top:'+y+';width:4px;height:4px;background-color:red;overflow:hidden&quot;&gt;&lt;/div&gt;';
}

function mkLineH(x,y,h)
{
	this.htm += '&lt;div class=&quot;lineH&quot; style=&quot;left:'+x+'px;top:'+y+'px;height:'+h+'px&quot;&gt;&lt;/div&gt;';	
}

function mkLineW(x,y,w)
{
	this.htm += '&lt;div class=&quot;lineW&quot; style=&quot;left:'+x+'px;top:'+y+'px;width:'+w+'px&quot;&gt;&lt;/div&gt;';
}

function mkLinePts(x1,y1,x2,y2,d2pts) { //function added to draw lines with few points
  	this.printing = true;
	var dx = x2-x1;
	var dy = y2-y1;
	var darc = Math.sqrt(dx * dx + dy * dy); //arc length	
	var nb_pts = Math.round(darc / d2pts); // number of points on the arc
	var dx2pts = dx / nb_pts;
	var dy2pts = dy / nb_pts;
	var i = 0;
	this.mkDivPt(x1,y1);
	while (i &lt; nb_pts) {
		++i;
		this.mkDivPt(Math.round(x1 + dx2pts * i), Math.round(y1 + dy2pts * i));
		//this.mkDiv(Math.round(x1 + dx2pts * i), Math.round(y1 + dy2pts * i),this.ptSize,this.ptSize);
	}
}

function mkRect(x, y, w, h, thickness)
{
	this.drawLineH(x, y, h);
	this.drawLineH(x+w, y,h);
	this.drawLineW(x, y+h,w+thickness);
	this.drawLineW(x, y,w);
}


function jsGraphics(id, wnd)
{
	this.setColor = new Function('arg', 'this.color = arg.toLowerCase();');

	this.setStroke = function(a,b)
	{
		this.stroke = a;
		this.ptSize = b;
			this.drawRect = mkRect;
			this.drawLinePts = mkLinePts;
			this.drawLineH = mkLineH;
			this.drawLineW = mkLineW;
	};
	
	this.drawPolylinePts = function(x, y, d) {
		for (var i=0; i&lt;x.length - 1 ; i++) this.drawLinePts(x[i], y[i], x[i+1], y[i+1], d);
	}


	this.setPrintable = function()
	{
		this.mkDivPt = mkDivPt;
	};

	this.clear = function()
	{
		this.htm = &quot;&quot;;
		if (this.cnv) this.cnv.innerHTML = this.defhtm;
	};


	this.setStroke(1);
	this.color = '#000000';
	this.htm = '';
	this.wnd = wnd || window;

	if (!(jg_ie || jg_dom || jg_ihtm)) chkDHTM();
	if (typeof id != 'string' || !id) {this.paint = pntDoc;}
	else
	{
		this.cnv = document.all? (this.wnd.document.all[id] || null)
			: document.getElementById? (this.wnd.document.getElementById(id) || null)
			: null;
		this.defhtm = (this.cnv &amp;&amp; this.cnv.innerHTML)? this.cnv.innerHTML : '';
		this.paint = jg_dom? pntCnvDom : jg_ie? pntCnvIe : jg_ihtm? pntCnvIhtm : pntCnv;
	}

	this.setPrintable();
}
--- NEW FILE: tree.js ---
(This appears to be a binary file; contents omitted.)

--- NEW FILE: x_event_nn4.js ---
// x_event_nn4.js
// For NN4 use this file instead of x_event.js. xInclude() will do this for you automatically.

// X v3.15, Cross-Browser DHTML Library from Cross-Browser.com
// Copyright (c) 2002,2003,2004 Michael Foster (<A HREF="https://lists.berlios.de/mailman/listinfo/spip-carto-cvs">mike at cross-browser.com</A>)
// This library is distributed under the terms of the LGPL (gnu.org)

// partly modified by Pierre GIRAUD (<A HREF="https://lists.berlios.de/mailman/listinfo/spip-carto-cvs">p_giraud at hotmail.com</A>)
// events list is not limited to mousemove for NN4

function xAddEventListener(e,eventType,eventListener,useCapture) {
  if(!(e=xGetElementById(e))) return;
  eventType=eventType.toLowerCase();
  if((!xIE4Up &amp;&amp; !xOp7) &amp;&amp; e==window) {
    if(eventType=='resize') { window.xPCW=xClientWidth(); window.xPCH=xClientHeight(); window.xREL=eventListener; xResizeEvent(); return; }
    if(eventType=='scroll') { window.xPSL=xScrollLeft(); window.xPST=xScrollTop(); window.xSEL=eventListener; xScrollEvent(); return; }
  }
  var eh='e.on'+eventType+'=eventListener';
  if(e.addEventListener) e.addEventListener(eventType,eventListener,useCapture);
  else if(e.attachEvent) e.attachEvent('on'+eventType,eventListener);
  else if(e.captureEvents) {
    if(useCapture||eventType.indexOf('mouse')!=-1) { e.captureEvents(eval('Event.'+eventType.toUpperCase())); }
    eval(eh);
  }
  else eval(eh);
}
function xRemoveEventListener(e,eventType,eventListener,useCapture) {
  if(!(e=xGetElementById(e))) return;
  eventType=eventType.toLowerCase();
  if((!xIE4Up &amp;&amp; !xOp7) &amp;&amp; e==window) {
    if(eventType=='resize') { window.xREL=null; return; }
    if(eventType=='scroll') { window.xSEL=null; return; }
  }
  var eh='e.on'+eventType+'=null';
  if(e.removeEventListener) e.removeEventListener(eventType,eventListener,useCapture);
  else if(e.detachEvent) e.detachEvent('on'+eventType,eventListener);
  else if(e.releaseEvents) {
    if(useCapture||eventType.indexOf('mouse')!=-1) { e.releaseEvents(eval('Event.'+eventType.toUpperCase())); }
    eval(eh);
  }
  else eval(eh);
}

var xMac = (xUA.indexOf(&quot;mac&quot;)!=-1);
function xEvent(evt) { // cross-browser event object prototype
  this.type = '';
  this.target = null;
  this.pageX = 0;
  this.pageY = 0;
  this.offsetX = 0;
  this.offsetY = 0;
  this.keyCode = 0;
  var e = evt ? evt : window.event;
  if(!e) return;
  if(e.type) this.type = e.type;
  if(e.target) this.target = e.target;
  else if(e.srcElement) this.target = e.srcElement;
  else if(xNN4) this.target = xLayerFromPoint(e.pageX, e.pageY);
  if(xOp5or6) { this.pageX = e.clientX; this.pageY = e.clientY; }
  else if(xDef(e.pageX,e.pageY)) { this.pageX = e.pageX; this.pageY = e.pageY; } // v3.14
  else if(xDef(e.clientX,e.clientY)) { this.pageX = e.clientX + xScrollLeft(); this.pageY = e.clientY + xScrollTop(); }
  if(xDef(e.offsetX,e.offsetY)) { this.offsetX = e.offsetX; this.offsetY = e.offsetY; }
  else if(xDef(e.layerX,e.layerY)) { this.offsetX = e.layerX; this.offsetY = e.layerY; }
  else { this.offsetX = this.pageX - xPageX(this.target); this.offsetY = this.pageY - xPageY(this.target); }
  // mac specificities
  if (xIE &amp;&amp; xMac) {
    this.offsetX += xScrollLeft(); //document.body.scrollLeft;
    this.offsetY += xScrollTop(); //document.body.scrollTop;
  }
  //
  if (e.keyCode) { this.keyCode = e.keyCode; } // for moz/fb, if keyCode==0 use which
  else if (xDef(e.which)) { this.keyCode = e.which; }
  
}
function xLayerFromPoint(x,y,root) { // only for nn4
  var i, hn=null, hz=-1, cn;
  if (!root) root = window;
  for (i=0; i &lt; root.document.layers.length; ++i) {
    cn = root.document.layers[i];
    if (cn.visibility != &quot;hide&quot; &amp;&amp; x &gt;= cn.pageX &amp;&amp; x &lt;= cn.pageX + cn.clip.right &amp;&amp; y &gt;= cn.pageY &amp;&amp; y &lt;= cn.pageY + cn.clip.bottom ) {
      if (cn.zIndex &gt; hz) { hz = cn.zIndex; hn = cn; }
    }
  }
  if (hn) {
    cn = xLayerFromPoint(x,y,hn);
    if (cn) hn = cn;
  }
  return hn;
}
function xResizeEvent() { // window resize event simulation
  if (window.xREL) setTimeout('xResizeEvent()', 250);
  var cw = xClientWidth(), ch = xClientHeight();
  if (window.xPCW != cw || window.xPCH != ch) { window.xPCW = cw; window.xPCH = ch; if (window.xREL) window.xREL(); }
}
function xScrollEvent() { // window scroll event simulation
  if (window.xSEL) setTimeout('xScrollEvent()', 250);
  var sl = xScrollLeft(), st = xScrollTop();

  if (window.xPSL != sl || window.xPST != st) { window.xPSL = sl; window.xPST = st; if (window.xSEL) window.xSEL(); }
}
// end x_event_nn4.js

--- NEW FILE: navTools.js ---
// Global variables

// dhtmlBox constructor
function dhtmlBox() {
  this.anchor = xGetElementById(&quot;mapAnchorDiv&quot;);
  this.target = xGetElementById(&quot;mainDHTMLDiv&quot;);
  this.image = xGetElementById(&quot;mapImageDiv&quot;);
  this.canvas = xGetElementById(&quot;myCanvasDiv&quot;);
  this.canvas2 = xGetElementById(&quot;myCanvas2Div&quot;);
  this.displayContainer = xGetElementById(&quot;diplayContainerDiv&quot;);
  this.displayCoords = xGetElementById(&quot;displayCoordsDiv&quot;);
  this.displayMeasure = xGetElementById(&quot;displayMeasureDiv&quot;);

  this.x1 = this.y1 = this.x2 = this.y2 = -1;
  this.drag = false;
  this.isActive = false;
  this.dblClick = false;
  this.keyEscape = false;
}

// method prototypes
function dhtmlBox_initialize() {
  jg = new jsGraphics(this.canvas.id); // a drawing canvas for the lines and points
  jg2 = new jsGraphics(this.canvas2.id); // a drawing canvas for the last moving vertex

  dhtmlBox.changeTool() //make the previous tool selected the current one
  
  this.target.style.zIndex = 1000;

  this.width = xWidth(this.anchor);
  this.height = xHeight(this.anchor);

  this.resizeAndMoveDivs()

  if (this.dispPos == &quot;top&quot;) this.dispPos = -13;
  else if (this.dispPos == &quot;bottom&quot;) this.dispPos = this.height;
  else this.dispPos = 0;
  xMoveTo(this.displayContainer,xPageX(this.anchor),xPageY(this.anchor) + this.dispPos);

}

function dhtmlBox_resizeAndMoveDivs() {
  xResizeTo(this.image,this.width,this.height)
  xResizeTo(this.target,this.width,this.height)
  xResizeTo(this.canvas,this.width,this.height)
  xResizeTo(this.canvas2,this.width,this.height)
  xWidth(this.displayContainer,this.width)

  xMoveTo(this.image,xPageX(this.anchor),xPageY(this.anchor))
  xMoveTo(this.target,xPageX(this.anchor),xPageY(this.anchor))
  xMoveTo(this.canvas,xPageX(this.anchor),xPageY(this.anchor))
  xMoveTo(this.canvas2,xPageX(this.anchor),xPageY(this.anchor))
  xShow(this.image)

  xClip(this.target,0,this.width,this.height,0)
  xClip(this.image,0,this.width,this.height,0)
}

// the mouse events are managed in this function according to the mapping tool selected
// shape accepted values : point, rectangle, line, polygon
// action : submit, measure
// cursorStyle : crosshair, help, move
// toolName : name of the tool (ie query, zoomin, ...)
function dhtmlBox_changetool() {
  // get the checked tool and its values
  for (var i =0; i &lt; myform.tool.length ; i++) {
    if (myform.tool[i].checked) {
	  var toolValues = myform.tool[i].value.split(&quot;,&quot;)
	  this.shapeType = toolValues[0]
	  this.action = toolValues[1]
	  this.cursorStyle = toolValues[2]
	  this.toolName = toolValues[3]
    }
  }
  
  // clear the drawing canvas
  jg.clear();

  xRemoveEventListener(this.target,'mousedown',this.domousedown)
  xRemoveEventListener(this.target,'mouseup',this.domouseup)
  xRemoveEventListener(this.target,'mousemove',this.domousemove)
  xRemoveEventListener(this.target,'mouseout',this.domouseout)
  xRemoveEventListener(this.target, 'dblclick', this.dodblclick)
  
  xAddEventListener(this.target,'mousedown',this.domousedown)
  xAddEventListener(this.target,'mouseup',this.domouseup)
  xAddEventListener(this.target,'mousemove',this.domousemove)
  xAddEventListener(this.target,'mouseout',this.domouseout)

  xAddEventListener(document,'keydown',this.dokeydown)
 
  this.isActive = false

  if (this.shapeType == 'polygon' || this.shapeType == 'line') {
    xAddEventListener(this.target,'dblclick', this.dodblclick)
  }
  
  this.displayMeasure.innerHTML = '';
  if (this.action == 'measure') {
  	this.measure = 0;
  }

  // cursor style
  if (this.target.style) this.target.style.cursor = this.cursorStyle
  jg.paint()
}

function dhtmlBox_mousedown(evt) {
  var e = new xEvent(evt);
  
  if (!(xUA.indexOf('mac_')!=-1 &amp;&amp; xUA.indexOf('msie')!=-1) &amp;&amp; evt.button == 2) { //right clic
    dhtmlBox.rightclic = true;
  } else {
    dhtmlBox.rightclic = false;

    dhtmlBox.x1 = dhtmlBox.x2 = e.offsetX;
    dhtmlBox.y1 = dhtmlBox.y2 = e.offsetY;
	
    if (dhtmlBox.shapeType == &quot;point&quot;) {
      jg.clear();  // if page not reloaded automaticaly, previous crosses are deleted
    }
	
	if (!dhtmlBox.isActive) {
	  dhtmlBox.isActive = true
	  dhtmlBox.dblClick = false
      dhtmlBox.Xpoints = new Array()
   	  dhtmlBox.Ypoints = new Array()
	  if (dhtmlBox.shapeType == 'polygon' || dhtmlBox.shapeType == 'line') { //init
      	  jg.clear();
	      //jg2.clear();
    	  dhtmlBox.cnv_clicks = 0;
	      dhtmlBox.draw_x = new Array();
    	  dhtmlBox.draw_y = new Array();
	      dhtmlBox.measure = 0;
		  dhtmlBox.dblClick = false;
    	  dhtmlBox.keyEscape = false;
	  }
    }
  }
  if (dhtmlBox.action == 'submit' &amp;&amp; (dhtmlBox.shapeType == 'polygon' || dhtmlBox.shapeType == 'line')) {
    dhtmlBox.drag = false; // to provide the curves draw (ie for polygon or line selection submit, TODO test if curves can be used
  } else {
	dhtmlBox.drag = true; // the mouse is down
  }
}

function dhtmlBox_mousemove(evt) {
  var e = new xEvent(evt);

  //show the coords display
  xShow(dhtmlBox.displayContainer);

  if(dhtmlBox.drag &amp;&amp; dhtmlBox.isActive) { //the mouse is down
    dhtmlBox.x2 = e.offsetX;
    dhtmlBox.y2 = e.offsetY;
	if (dhtmlBox.shapeType == 'point') {
      jg.clear();
      dhtmlBox.x1 = dhtmlBox.x2;
      dhtmlBox.y1 = dhtmlBox.y2;
    }
	jg2.clear();
    dhtmlBox.paint();
	if (dhtmlBox.shapeType == 'polygon') dhtmlBox.lastLinePaint(); // last line is drawn while moving
  }
  else if ((dhtmlBox.shapeType == 'polygon' || dhtmlBox.shapeType == 'line') &amp;&amp; dhtmlBox.isActive == true) {
      dhtmlBox.x2 = e.offsetX;
      dhtmlBox.y2 = e.offsetY;
      dhtmlBox.lastLinePaint(); // the last line is drawn while moving
  }
  // display the coordinates
  dhtmlBox.displayCoords.innerHTML = dhtmlBox.coord_msg + Math.round((e.offsetX * dhtmlBox.pixel_size) + dhtmlBox.boxx)  +&quot; / &quot;+ Math.round(((dhtmlBox.mapHeight - e.offsetY) * dhtmlBox.pixel_size) + dhtmlBox.boxy);
}

function dhtmlBox_mouseup(evt) {
  var e = new xEvent(evt);

  if (dhtmlBox.rightclic == true) {
    jg2.clear();
  } else if (dhtmlBox.isActive) {

    dhtmlBox.drag = false; //the mouse is now up

    dhtmlBox.x2 = e.offsetX;
    dhtmlBox.y2 = e.offsetY;

    //the box is too small
    if(((Math.abs(dhtmlBox.x1-dhtmlBox.x2) &lt;= dhtmlBox.jitter) || (Math.abs(dhtmlBox.y1-dhtmlBox.y2) &lt;= dhtmlBox.jitter)) &amp;&amp; dhtmlBox.shapeType == 'rectangle') {
      dhtmlBox.x2 = dhtmlBox.x1 = Math.abs(dhtmlBox.x1-dhtmlBox.x2) /2 + Math.min(dhtmlBox.x1, dhtmlBox.x2); //zoom to center of the box
      dhtmlBox.y2 = dhtmlBox.y1 = Math.abs(dhtmlBox.y1-dhtmlBox.y2) /2 + Math.min(dhtmlBox.y1, dhtmlBox.y2)
    }
	
	// rectangle draw finished
	if (dhtmlBox.shapeType == 'point' || dhtmlBox.shapeType == 'rectangle' || dhtmlBox.shapeType == 'pan') dhtmlBox.isActive = false;
	
	// polygon closed by click on the first point
	if (dhtmlBox.shapeType == 'polygon' &amp;&amp; Math.abs(dhtmlBox.x2 - dhtmlBox.draw_x[1]) &lt;= dhtmlBox.jitter &amp;&amp; Math.abs(dhtmlBox.y2 - dhtmlBox.draw_y[1]) &lt;= dhtmlBox.jitter &amp;&amp; dhtmlBox.draw_x.length &gt; 2) {
		dhtmlBox.keyEscape = true;
		dhtmlBox.isActive = false;
		jg2.clear();
	}
    dhtmlBox.paint();
  }
}

function dhtmlBox_mouseout(evt) {
  var e = new xEvent(evt);

  xHide(dhtmlBox.displayContainer);
  jg2.clear();
}

function dhtmlBox_dblclick(evt) {
  var e = new xEvent(evt)
  dhtmlBox.dblClick = true
  dhtmlBox.isActive = false
  jg2.clear()
  dhtmlBox.paint()
}

function dhtmlBox_keydown(evt) { // 
  if (evt.keyCode == '27') {
    dhtmlBox.keyEscape = true
    dhtmlBox.isActive = false
    jg2.clear()
	if (dhtmlBox.action == 'submit') {
		dhtmlBox.changeTool() // cancel the use of the current tool
		dhtmlBox.resizeAndMoveDivs()
		xHide(dhtmlBox.anchor)
	}
	else if (dhtmlBox.action == 'measure') {
		dhtmlBox.paint() //
	}
  }
}

function dhtmlBox_paint() { // draws alternatively boxes, lines, polylines, crosses, or pan the map
  var x, y, w, h;

  x = Math.min(this.x1, this.x2);
  y = Math.min(this.y1, this.y2);

  if (this.shapeType == 'pan') {
    var dx = this.x2 - this.x1
    var dy = this.y2 - this.y1

    xMoveTo(this.image,dx + xPageX(this.anchor),dy + xPageY(this.anchor))
    xClip(this.image,(dy&lt;0)? Math.abs(dy):0,(dx&gt;0)? this.width - dx : this.width,(dy&gt;0)? this.height-dy:this.height,(dx&lt;0)? Math.abs(dx):0)
	
	this.Xpoints[0] = dhtmlBox.width/2 - (dhtmlBox.x2 - dhtmlBox.x1)
    this.Ypoints[0] = dhtmlBox.height/2 - (dhtmlBox.y2 - dhtmlBox.y1)
    //xResizeTo(this.image,(dy&lt;0)? Math.abs(dy):0,(dx&gt;0)? this.width - dx : this.width,(dy&gt;0)? this.height-dy:this.height,(dx&lt;0)? Math.abs(dx):0);
  }
  else if (this.shapeType == 'point' ||
	(this.shapeType == 'rectangle' &amp;&amp; this.x1==this.x2 &amp;&amp; this.y1==this.y2)) { //draws only a cross
	jg.clear();
    jg.drawLineW(x-this.cursorsize,y - this.thickness /2,this.cursorsize * 2);
    jg.drawLineH(x - this.thickness /2,y-this.cursorsize ,this.cursorsize * 2);
    jg.paint();
	this.Xpoints[0] = x
	this.Ypoints[0] = y
	if (this.shapeType == 'rectangle') { // submit a rectangle coords (2 equal coords)
	  this.Xpoints[1] = this.x2
	  this.Ypoints[1] = this.y2
	}
  }
  else if (this.shapeType == 'rectangle') {
      w = Math.abs(this.x1-this.x2)
      h = Math.abs(this.y1-this.y2)
      jg.clear()
      jg.drawRect(x,y,w,h,this.thickness)
      jg.paint()
  	  this.Xpoints[0] = this.x1
	  this.Ypoints[0] = this.y1
	  this.Xpoints[1] = this.x2
	  this.Ypoints[1] = this.y2
  }
  else if (this.shapeType == 'line' || this.shapeType == 'polygon') {
    if (!this.keyEscape) { // Escape key is pressed
      ++this.cnv_clicks;
      this.draw_x[this.cnv_clicks] = this.x2;
      this.draw_y[this.cnv_clicks] = this.y2;
    }
    this.Xpoints[this.cnv_clicks - 1] = this.draw_x[this.cnv_clicks];
    this.Ypoints[this.cnv_clicks - 1] = this.draw_y[this.cnv_clicks];
    if (xUA.indexOf('mac_')!=-1 &amp;&amp; xUA.indexOf('msie')!=-1) { // IE/Mac specificity
	  if (!this.isActive &amp;&amp; this.shapeType == 'polygon') {
        this.Xpoints[this.cnv_clicks] = this.draw_x[1];
        this.Ypoints[this.cnv_clicks] = this.draw_y[1];	  	
	  }
      jg.clear();
      jg.drawPolylinePts(this.Xpoints,this.Ypoints, this.d2pts);
    }
    else {
        jg.drawLinePts(this.draw_x[this.cnv_clicks],this.draw_y[this.cnv_clicks],this.draw_x[this.cnv_clicks - 1],this.draw_y[this.cnv_clicks - 1],this.d2pts);
      	if (!this.isActive  &amp;&amp; this.shapeType == 'polygon') // close the polygon
          jg.drawLinePts(this.draw_x[this.cnv_clicks],this.draw_y[this.cnv_clicks],this.draw_x[1],this.draw_y[1],this.d2pts);		
      }
    }
    jg.paint();
	// submit the form with the values
	if (dhtmlBox.action == 'submit' &amp;&amp; !this.isActive ) {
		dhtmlBox.submitForm()
	}
	if (dhtmlBox.action == 'measure') {
		dhtmlBox.measureShape()
	}
}

function dhtmlBox_lastLinePaint() {

  var x2 = this.x2;
  var y2 = this.y2;
  var x = this.draw_x[this.cnv_clicks];
  var y = this.draw_y[this.cnv_clicks];
  var x0 = this.draw_x[1];
  var y0 = this.draw_y[1];

//  if (xIE || xUA.indexOf('mac')!=-1) { //use the drawing API
  if (xUA.indexOf('mac')!=-1) { //use the drawing API
    jg2.clear();
    jg2.drawLinePts(x2,y2,x,y,this.d2pts); //draw the last vertex
    if (this.shapeType == 'polygon') {
      jg2.drawLinePts(x2,y2,x0,y0,this.d2pts) // also draw the line to close the polygon
    }
    jg2.paint()
  }
  else { //doesn't use the drawing API
  
    if (this.canvas2.innerHTML == '') { // create the DIVs if doesn't exist
      for (var i=0; i&lt; this.nbPts * 2; i++) {
        this[&quot;vertexPt&quot;+i] = xCreateElement('div')
        xAppendChild(this.canvas2,this[&quot;vertexPt&quot;+i],200)
        this[&quot;vertexPt&quot;+i].className = &quot;point&quot;
        xHide(this[&quot;vertexPt&quot;+i])
        if (this[&quot;vertexPt&quot;+i].style) this[&quot;vertexPt&quot;+i].style.position = &quot;absolute&quot;
      }
    }
    var dx = x2 - x
    var dy = y2 - y
    for (var i=0;i&lt;this.nbPts;i++) {
      var a = this[&quot;vertexPt&quot;+i]
      xMoveTo(a,x + dx *i/ this.nbPts,y + dy *i/ this.nbPts)
      xShow(a)
    }
    if (this.shapeType == 'polygon') {
      var dx0 = x2 - x0
      var dy0 = y2 - y0
      for (var i=this.nbPts;i&lt;this.nbPts * 2;i++) {
        var a = this[&quot;vertexPt&quot;+i]
        xMoveTo(a,x0 + dx0 * (i-this.nbPts)/this.nbPts,y0 + dy0 * (i-this.nbPts) / this.nbPts)
        xShow(a);
      }
    }
  }
}

function dhtmlBox_submitForm() {
	var coords = new String()
	if (this.dblClick) { // manually delete 2 not needed values
		this.Xpoints.splice(this.Xpoints.length - 2, 2)
	}
	for (i = 0; i &lt; this.Xpoints.length; i++) {
		coords += this.Xpoints[i] +&quot;,&quot; + this.Ypoints[i] + &quot;;&quot;
	}
	if (dhtmlBox.shapeType == 'polygon') coords += this.Xpoints[0] +&quot;,&quot; + this.Ypoints[0] + &quot;;&quot;  // last point equal to first
	myform.selection_coords.value = coords.substring(0,coords.length - 1) // delete the last coma
	// change the value of the tool form input
/*    for (var i =0; i &lt; myform.tool.length ; i++) {
        if (myform.tool[i].checked) {
		    myform.tool[i].value = this.toolName
		}
	}
*/
	myform.selection_type.value = (this.shapeType == &quot;pan&quot;) ? &quot;point&quot; : this.shapeType
//	alert (&quot;type : &quot; + myform.selection_coords.value + &quot;\n coords : &quot; + myform.selection_coords.value)
	xShow(dhtmlBox.anchor);
   	myform.submit();
}

function dhtmlBox_measureShape() {
	if (this.shapeType == 'line') { //Calculate the distance and display it
	  if (this.cnv_clicks &gt; 1 &amp;&amp; !this.keyEscape) {
        // distance calculation
        this.dist_x = (this.draw_x[this.cnv_clicks] - this.draw_x[this.cnv_clicks - 1]) * this.pixel_size;
        this.dist_y = (this.draw_y[this.cnv_clicks] - this.draw_y[this.cnv_clicks - 1]) * this.pixel_size;
        this.measure += Math.sqrt(this.dist_x * this.dist_x + this.dist_y * this.dist_y);
      }
	  
      if (this.dist_unit.indexOf('k') != -1) this.measure = Math.round(this.measure*100)/100
      else this.measure = Math.round(this.measure)
      this.displayMeasure.innerHTML = this.dist_msg + this.measure.toString() + this.dist_unit
	}
	if (this.shapeType == 'polygon') { // calculate the surface and display it
	  if (this.cnv_clicks &gt; 1  &amp;&amp; !this.keyEscape) {
        //surface calculation
        var i = 0;
        this.measure = 0;
        while (i &lt; this.cnv_clicks - 1) {
          this.measure += this.Xpoints[i] * this.Ypoints[i+1] - this.Xpoints[i+1] * this.Ypoints[i];
          ++i;
        }
        this.measure += this.Xpoints[this.cnv_clicks -1] * this.Ypoints[0] - this.Xpoints[0] * this.Ypoints[this.cnv_clicks -1];
        var pix_surf = this.pixel_size * this.pixel_size;
        this.measure = Math.abs(this.measure.toString()) / 2 * pix_surf;
	  }
      if (this.surf_unit.indexOf('k') != -1) this.measure = Math.round(this.measure*10000)/10000
	  else this.measure = Math.round(this.measure)
      this.displayMeasure.innerHTML = this.surf_msg+ this.measure +this.surf_unit;
    }
}

new dhtmlBox(0);

dhtmlBox.prototype.initialize = dhtmlBox_initialize // create instance method
dhtmlBox.prototype.resizeAndMoveDivs = dhtmlBox_resizeAndMoveDivs
dhtmlBox.prototype.domousedown = dhtmlBox_mousedown
dhtmlBox.prototype.domousemove = dhtmlBox_mousemove
dhtmlBox.prototype.domouseup = dhtmlBox_mouseup
dhtmlBox.prototype.domouseout = dhtmlBox_mouseout
dhtmlBox.prototype.dodblclick = dhtmlBox_dblclick
dhtmlBox.prototype.dokeydown = dhtmlBox_keydown
dhtmlBox.prototype.paint = dhtmlBox_paint
dhtmlBox.prototype.lastLinePaint = dhtmlBox_lastLinePaint // draw the last straight vertex for the measure tool
dhtmlBox.prototype.changeTool = dhtmlBox_changetool
dhtmlBox.prototype.submitForm = dhtmlBox_submitForm
dhtmlBox.prototype.measureShape = dhtmlBox_measureShape

--- NEW FILE: Copie de navTools.js ---
// Global variables

// dhtmlBox constructor
function dhtmlBox() {
  this.anchor = xGetElementById(&quot;mapAnchorDiv&quot;);
  this.target = xGetElementById(&quot;mainDHTMLDiv&quot;);
  this.image = xGetElementById(&quot;mapImageDiv&quot;);
  this.canvas = xGetElementById(&quot;myCanvasDiv&quot;);
  this.canvas2 = xGetElementById(&quot;myCanvas2Div&quot;);
  this.displayContainer = xGetElementById(&quot;diplayContainerDiv&quot;);
  this.displayCoords = xGetElementById(&quot;displayCoordsDiv&quot;);
  this.displayMeasure = xGetElementById(&quot;displayMeasureDiv&quot;);

  this.x1 = this.y1 = this.x2 = this.y2 = -1;
  this.drag = false;
  this.isActive = false;
  this.dblClick = false;
  this.keyEscape = false;
}

// method prototypes
function dhtmlBox_initialize() {
  jg = new jsGraphics(this.canvas.id); // a drawing canvas for the lines and points
  jg2 = new jsGraphics(this.canvas2.id); // a drawing canvas for the last moving vertex

  // make the previous tool selected the current one
  for (var i =0; i &lt; myform.tool.length ; i++) {
    if (myform.tool[i].checked) {
      dhtmlBox.changeTool('','','',myform.tool[i].value);
    }
  }
  
  // HACK FOR selection tool: find a better solution !!
  if (myform.tool.length &gt;= 5 &amp;&amp; myform.tool[4].checked) {
     dhtmlBox.changeTool('query');
  }
  
  this.target.style.zIndex = 1000;

  this.width = xWidth(this.anchor);
  this.height = xHeight(this.anchor);

  xResizeTo(this.image,this.width,this.height);
  xResizeTo(this.target,this.width,this.height);
  xResizeTo(this.canvas,this.width,this.height);
  xResizeTo(this.canvas2,this.width,this.height);
  xWidth(this.displayContainer,this.width);

  xMoveTo(this.image,xPageX(this.anchor),xPageY(this.anchor));
  xMoveTo(this.target,xPageX(this.anchor),xPageY(this.anchor));
  xMoveTo(this.canvas,xPageX(this.anchor),xPageY(this.anchor));
  xMoveTo(this.canvas2,xPageX(this.anchor),xPageY(this.anchor));
  xShow(this.image);

  if (this.dispPos == &quot;top&quot;) this.dispPos = -13;
  else if (this.dispPos == &quot;bottom&quot;) this.dispPos = this.height;
  else this.dispPos = 0;
  xMoveTo(this.displayContainer,xPageX(this.anchor),xPageY(this.anchor) + this.dispPos);

  xClip(this.target,0,this.width,this.height,0);
}

/*
function dhtmlBox_changetool(tool) {// the mouse events are managed in this function according to the mapping tool selected
  myform.tool.value = tool;
  this.currentTool = tool.toLowerCase();

  // clear the drawing canvas
  jg.clear();

  xRemoveEventListener(this.target,'mousedown',this.domousedown);
  xRemoveEventListener(this.target,'mouseup',this.domouseup);
  xRemoveEventListener(this.target,'mousemove',this.domousemove);
  xRemoveEventListener(this.target,'mouseout',this.domouseout);
  xRemoveEventListener(this.target, 'dblclick', this.dodblclick);
  
  xAddEventListener(this.target,'mousedown',this.domousedown);
  xAddEventListener(this.target,'mouseup',this.domouseup);
  xAddEventListener(this.target,'mousemove',this.domousemove);
  xAddEventListener(this.target,'mouseout',this.domouseout);

  xAddEventListener(document,'keydown',this.dokeydown);

  if (this.currentTool == 'distance' || this.currentTool == 'surface' || this.currentTool == 'polygon' || this.currentTool == 'line') {
    this.isActive = false;
    this.distance = 0;
    this.displayCoords.innerHTML = '';
    this.displayMeasure.innerHTML = '';
    xAddEventListener(this.target,'dblclick', this.dodblclick);
  }

  // cursor style
  if (this.currentTool == 'zoom_in' || this.currentTool == 'zoom_out' || this.currentTool == 'distance' || this.currentTool == 'surface' || this.currentTool == 'polygon' || this.currentTool == 'line') {
    if (this.target.style) this.target.style.cursor = &quot;crosshair&quot;;
  } else if (this.currentTool == 'pan') {
    if (this.target.style) this.target.style.cursor = &quot;move&quot;;
  } else if (this.currentTool == 'query') {
    if (this.target.style) this.target.style.cursor = &quot;help&quot;;
  }
  jg.paint();
}
*/

// the mouse events are managed in this function according to the mapping tool selected
// shape accepted values : point, rectangle, line, polygon
// action : submit, measure
// cursorStyle : crosshair, help, move
// TODO tool name not necessary
// tool : name of the tool (ie query, zoomin,
function dhtmlBox_changetool(shape,action,cursorStyle,tool) {
//  myform.tool.value = tool;
  this.currentTool = tool.toLowerCase();
  this.shapeType = shape;
  this.action = action;
  // clear the drawing canvas
  jg.clear();

  xRemoveEventListener(this.target,'mousedown',this.domousedown);
  xRemoveEventListener(this.target,'mouseup',this.domouseup);
  xRemoveEventListener(this.target,'mousemove',this.domousemove);
  xRemoveEventListener(this.target,'mouseout',this.domouseout);
  xRemoveEventListener(this.target, 'dblclick', this.dodblclick);
  
  xAddEventListener(this.target,'mousedown',this.domousedown);
  xAddEventListener(this.target,'mouseup',this.domouseup);
  xAddEventListener(this.target,'mousemove',this.domousemove);
  xAddEventListener(this.target,'mouseout',this.domouseout);

  xAddEventListener(document,'keydown',this.dokeydown);
  
  this.isActive = false;

  if (this.shapeType == 'polygon' || this.shapeType == 'line') {
    xAddEventListener(this.target,'dblclick', this.dodblclick);
  }

  // cursor style
  if (this.target.style) this.target.style.cursor = cursorStyle;
  jg.paint();
}

function dhtmlBox_mousedown(evt) {
  var e = new xEvent(evt);
  
  if (!(xUA.indexOf('mac_')!=-1 &amp;&amp; xUA.indexOf('msie')!=-1) &amp;&amp; evt.button == 2) { //right clic
    dhtmlBox.rightclic = true;
  } else {
    dhtmlBox.rightclic = false;

    dhtmlBox.x1 = dhtmlBox.x2 = e.offsetX;
    dhtmlBox.y1 = dhtmlBox.y2 = e.offsetY;
	
    if (dhtmlBox.shapeType == &quot;point&quot;) {
      jg.clear();  // if page not reloaded automaticaly, previous crosses are deleted
    }
	
	if (!dhtmlBox.isActive) {
	  dhtmlBox.isActive = true;
	  if (dhtmlBox.shapeType == 'polygon' || dhtmlBox.shapeType == 'line') { //init
      	  jg.clear();
	      //jg2.clear();
    	  dhtmlBox.cnv_clicks = 0;
	      dhtmlBox.draw_x = new Array();
    	  dhtmlBox.draw_y = new Array();
	      dhtmlBox.Xpoints = new Array();
    	  dhtmlBox.Ypoints = new Array();
	      dhtmlBox.distance = 0;
		  dhtmlBox.dblClick = false;
    	  dhtmlBox.keyEscape = false;
	  }
    }

  }
  if (dhtmlBox.action == 'submit' &amp;&amp; (dhtmlBox.shapeType == 'polygon' || dhtmlBox.shapeType == 'line')) {
    dhtmlBox.drag = false; // to provide the curves draw (ie for polygon or line selection submit, TODO test if curves can be used
  } else {
	dhtmlBox.drag = true; // the mouse is down
  }
}

function dhtmlBox_mousemove(evt) {
  var e = new xEvent(evt);

  //show the coords display
  xShow(dhtmlBox.displayContainer);

  if(dhtmlBox.drag) { //the mouse is down
    dhtmlBox.x2 = e.offsetX;
    dhtmlBox.y2 = e.offsetY;
	if (dhtmlBox.shapeType == 'point') {
      jg.clear();
      dhtmlBox.x1 = dhtmlBox.x2;
      dhtmlBox.y1 = dhtmlBox.y2;
    }
    dhtmlBox.paint();
  }
  else if ((dhtmlBox.shapeType == 'polygon' || dhtmlBox.shapeType == 'line') &amp;&amp; dhtmlBox.isActive == true) {
      dhtmlBox.x2 = e.offsetX;
      dhtmlBox.y2 = e.offsetY;
      dhtmlBox.lastLinePaint(); // the last line is drawn while moving
  }
    // display the coordinates
    dhtmlBox.displayCoords.innerHTML = dhtmlBox.coord_msg + Math.round((e.offsetX * dhtmlBox.pixel_size) + dhtmlBox.boxx)  +&quot; / &quot;+ Math.round(((dhtmlBox.mapHeight - e.offsetY) * dhtmlBox.pixel_size) + dhtmlBox.boxy);
}

function dhtmlBox_mouseup(evt) {
  var e = new xEvent(evt);

  if (dhtmlBox.rightclic == true) {
    jg2.clear();
  } else {

    dhtmlBox.drag = false; //the mouse is now up

    dhtmlBox.x2 = e.offsetX;
    dhtmlBox.y2 = e.offsetY;

    //the box is too small
    if(((Math.abs(dhtmlBox.x1-dhtmlBox.x2) &lt;= dhtmlBox.jitter) || (Math.abs(dhtmlBox.y1-dhtmlBox.y2) &lt;= dhtmlBox.jitter)) &amp;&amp; dhtmlBox.currentTool == 'zoom_in') {
      dhtmlBox.x2 = dhtmlBox.x1 = Math.abs(dhtmlBox.x1-dhtmlBox.x2) /2 + Math.min(dhtmlBox.x1, dhtmlBox.x2); //zoom to center of the box
      dhtmlBox.y2 = dhtmlBox.y1 = Math.abs(dhtmlBox.y1-dhtmlBox.y2) /2 + Math.min(dhtmlBox.y1, dhtmlBox.y2)
    }
	
	// rectangle draw finished
	if (dhtmlBox.shapeType == 'point' || dhtmlBox.shapeType == 'rectangle') dhtmlBox.isActive = false;
	
	// polygon closed by click on the first point
	if (dhtmlBox.shapeType == 'polygon' &amp;&amp; Math.abs(dhtmlBox.x2 - dhtmlBox.draw_x[1]) &lt;= dhtmlBox.jitter &amp;&amp; Math.abs(dhtmlBox.y2 - dhtmlBox.draw_y[1]) &lt;= dhtmlBox.jitter &amp;&amp; dhtmlBox.draw_x.length &gt; 2) {
		dhtmlBox.keyEscape = true;
		dhtmlBox.isActive = false;
		jg2.clear();
	}
    dhtmlBox.paint();
  }
}

function dhtmlBox_mouseout(evt) {
  var e = new xEvent(evt);

  xHide(dhtmlBox.displayContainer);
  jg2.clear();
}

function dhtmlBox_dblclick(evt) {
  var e = new xEvent(evt)
  dhtmlBox.dblClick = true
  dhtmlBox.isActive = false
  jg2.clear()
  dhtmlBox.paint()
}

function dhtmlBox_keydown(evt) { // 
  evt = (evt) ? evt : ((event) ? event : null)
  dhtmlBox = dhtmlBox
  if (evt.keyCode == '27' &amp;&amp; (dhtmlBox.shapeType == 'polygon'  || dhtmlBox.shapeType == 'line')) {
    dhtmlBox.keyEscape = true
    dhtmlBox.isActive = false
    jg2.clear()
    dhtmlBox.paint()
  }
}

function dhtmlBox_paint() { // draws alternatively boxes, lines, polylines, crosses, or pan the map
  var x, y, w, h;

  x = Math.min(this.x1, this.x2);
  y = Math.min(this.y1, this.y2);

  if (this.shapeType == 'point') { //draws only a cross
      jg.drawLineW(x-this.cursorsize,y - this.thickness /2,this.cursorsize * 2);
      jg.drawLineH(x - this.thickness /2,y-this.cursorsize ,this.cursorsize * 2);
      jg.paint();
  }
  else if (this.shapeType == 'rectangle') {
    if(this.x1==this.x2 &amp;&amp; this.y1==this.y2) {
        jg.clear()
        jg.drawLineW(x-this.cursorsize,y - this.thickness /2,this.cursorsize * 2)
        jg.drawLineH(x - this.thickness /2,y-this.cursorsize ,this.cursorsize * 2)
        jg.paint()

    } else {
      w = Math.abs(this.x1-this.x2)
      h = Math.abs(this.y1-this.y2)
      jg.clear()
      jg.drawRect(x,y,w,h,this.thickness)
      jg.paint()
    }
  }
  else if (this.currentTool == 'pan') {
    var dx,dy

    dx = this.x2 - this.x1
    dy = this.y2 - this.y1

    xMoveTo(this.image,dx + xPageX(this.anchor),dy + xPageY(this.anchor))
    xClip(this.image,(dy&lt;0)? Math.abs(dy):0,(dx&gt;0)? this.width - dx : this.width,(dy&gt;0)? this.height-dy:this.height,(dx&lt;0)? Math.abs(dx):0)
    //xResizeTo(this.image,(dy&lt;0)? Math.abs(dy):0,(dx&gt;0)? this.width - dx : this.width,(dy&gt;0)? this.height-dy:this.height,(dx&lt;0)? Math.abs(dx):0);
  }

  else if (this.shapeType == 'line') {
    if (!this.keyEscape) { // Escape key is pressed
      ++this.cnv_clicks;
      this.draw_x[this.cnv_clicks] = this.x2;
      this.draw_y[this.cnv_clicks] = this.y2;
    }
    this.Xpoints[this.cnv_clicks - 1] = this.draw_x[this.cnv_clicks];
    this.Ypoints[this.cnv_clicks - 1] = this.draw_y[this.cnv_clicks];
    if (xUA.indexOf('mac_')!=-1 &amp;&amp; xUA.indexOf('msie')!=-1) { // IE/Mac specificity
      jg.clear();
      jg.drawPolylinePts(this.Xpoints,this.Ypoints, this.d2pts);
    }
    else {
        jg.drawLinePts(this.draw_x[this.cnv_clicks],this.draw_y[this.cnv_clicks],this.draw_x[this.cnv_clicks - 1],this.draw_y[this.cnv_clicks - 1],this.d2pts);
    }
	if (this.action == 'measure') { //Calculate the distance and display it
	  if (this.cnv_clicks &gt; 1 &amp;&amp; !this.keyEscape) {
        // distance calculation
        this.dist_x = (this.draw_x[this.cnv_clicks] - this.draw_x[this.cnv_clicks - 1]) * this.pixel_size;
        this.dist_y = (this.draw_y[this.cnv_clicks] - this.draw_y[this.cnv_clicks - 1]) * this.pixel_size;
        this.distance += Math.sqrt(this.dist_x * this.dist_x + this.dist_y * this.dist_y);
      }
      if (this.dist_unit == ' m.') this.distance = Math.round(this.distance);
      else if (this.dist_unit == ' km.') this.distance = Math.round(this.distance*100)/100;
      this.displayMeasure.innerHTML = this.dist_msg + this.distance.toString() + this.dist_unit;
	}
    jg.paint();
  }
  else if (this.shapeType == 'polygon') {
    if (!this.keyEscape) { // Escape key is pressed
      ++this.cnv_clicks;
      this.draw_x[this.cnv_clicks] = this.x2;
      this.draw_y[this.cnv_clicks] = this.y2;
    }
    this.Xpoints[this.cnv_clicks - 1] = this.draw_x[this.cnv_clicks];
    this.Ypoints[this.cnv_clicks - 1] = this.draw_y[this.cnv_clicks];
    if (xUA.indexOf('mac_')!=-1 &amp;&amp; xUA.indexOf('msie')!=-1) { // IE/Mac specificity
      if (!this.isActive) { // close the polygon
        this.Xpoints[this.cnv_clicks] = this.draw_x[1];
        this.Ypoints[this.cnv_clicks] = this.draw_y[1];
      }
      jg.clear();
      jg.drawPolylinePts(this.Xpoints,this.Ypoints, this.d2pts);
    }
    else {
      jg.drawLinePts(this.draw_x[this.cnv_clicks],this.draw_y[this.cnv_clicks],this.draw_x[this.cnv_clicks - 1],this.draw_y[this.cnv_clicks - 1],this.d2pts);
      if (!this.isActive) { // close the polygon
        jg.drawLinePts(this.draw_x[this.cnv_clicks],this.draw_y[this.cnv_clicks],this.draw_x[1],this.draw_y[1],this.d2pts);		
      }
    }

	if (this.action == 'measure') { // calculate the surface and display it
	  if (this.cnv_clicks &gt; 1  &amp;&amp; !this.keyEscape) {
        //surface calculation
        var i = 0;
        this.distance = 0;
        while (i &lt; this.cnv_clicks - 1) {
          this.distance += this.Xpoints[i] * this.Ypoints[i+1] - this.Xpoints[i+1] * this.Ypoints[i];
          ++i;
        }
        this.distance += this.Xpoints[this.cnv_clicks -1] * this.Ypoints[0] - this.Xpoints[0] * this.Ypoints[this.cnv_clicks -1];
        var pix_surf = this.pixel_size * this.pixel_size;
        this.distance = Math.abs(this.distance.toString()) / 2 * pix_surf;
	  }
      if (this.surf_unit == ' m2.') this.distance = Math.round(this.distance);
      else if (this.surf_unit == ' km2.') this.distance = Math.round(this.distance*10000)/10000;
      this.displayMeasure.innerHTML = this.surf_msg+ this.distance +this.surf_unit;
    }
	jg.paint();
	

	}
	// submit the form with the values
	if (dhtmlBox.action == 'submit' &amp;&amp; !this.isActive ) {
		if (dhtmlBox.shapeType == 'point') {
			myform.selection_coords.value = x+&quot;,&quot;+y
		}
		else if (dhtmlBox.shapeType == 'rectangle') {
			dhtmlBox.removeEventsWait();
      		myform.selection_coords.value = dhtmlBox.x1+&quot; &quot;+dhtmlBox.y1+&quot;,&quot;+dhtmlBox.x2+&quot; &quot;+dhtmlBox.y2
		}
		else if (dhtmlBox.shapeType == 'line' || dhtmlBox.shapeType == 'polygon') {
			var coords = new String()
			for (i = 0; i &lt; this.Xpoints.length; i++) {
				coords += this.Xpoints[i] +&quot; &quot; + this.Ypoints[i] + &quot;,&quot;
			}
			if (dhtmlBox.shapeType == 'polygon') coords += this.Xpoints[0] +&quot; &quot; + this.Ypoints[0] + &quot;,&quot;  // last point equal to first
			myform.selection_coords.value = coords.substring(0,coords.length - 1)

		}
		alert (myform.selection_coords.value)
		xShow(dhtmlBox.anchor);
      	myform.submit();		
  }
}


function dhtmlBox_lastLinePaint() {

  var x2 = this.x2;
  var y2 = this.y2;
  var x = this.draw_x[this.cnv_clicks];
  var y = this.draw_y[this.cnv_clicks];
  var x0 = this.draw_x[1];
  var y0 = this.draw_y[1];

  if (xIE || xUA.indexOf('mac')!=-1) { //use the drawing API
    jg2.clear();
    jg2.drawLinePts(x2,y2,x,y,this.d2pts); //draw the last vertex
    if (this.shapeType == 'polygon') {
      jg2.drawLinePts(x2,y2,x0,y0,this.d2pts); // also draw the line to close the polygon
    }
    jg2.paint();
  }
  else { //doesn't use the drawing API
    if (this.canvas2.innerHTML == '') { // create the DIVs if doesn't exist
      for (var i=0; i&lt; this.nbPts * 2; i++) {
        this[&quot;vertexPt&quot;+i] = xCreateElement('div');
        xAppendChild(this.canvas2,this[&quot;vertexPt&quot;+i],200);
        this[&quot;vertexPt&quot;+i].className = &quot;point&quot;;
        xHide(this[&quot;vertexPt&quot;+i]);
        if (this[&quot;vertexPt&quot;+i].style) this[&quot;vertexPt&quot;+i].style.position = &quot;absolute&quot;;
      }
    }
    var dx = x2 - x;
    var dy = y2 - y;
    for (var i=0;i&lt;this.nbPts;i++) {
      var a = this[&quot;vertexPt&quot;+i];
      xMoveTo(a,x + dx *i/ this.nbPts,y + dy *i/ this.nbPts);
      xShow(a);
    }
    if (this.shapeType == 'polygon') {
      var dx0 = x2 - x0;
      var dy0 = y2 - y0;
      for (var i=this.nbPts;i&lt;this.nbPts * 2;i++) {
        var a = this[&quot;vertexPt&quot;+i];
        xMoveTo(a,x0 + dx0 * (i-this.nbPts)/this.nbPts,y0 + dy0 * (i-this.nbPts) / this.nbPts);
        xShow(a);
      }
    }
  }
}



new dhtmlBox(0);

dhtmlBox.prototype.initialize = dhtmlBox_initialize; // create instance method
dhtmlBox.prototype.domousedown = dhtmlBox_mousedown;
dhtmlBox.prototype.domousemove = dhtmlBox_mousemove;
dhtmlBox.prototype.domouseup = dhtmlBox_mouseup;
dhtmlBox.prototype.domouseout = dhtmlBox_mouseout;
dhtmlBox.prototype.dodblclick = dhtmlBox_dblclick;
dhtmlBox.prototype.dokeydown = dhtmlBox_keydown;
dhtmlBox.prototype.paint = dhtmlBox_paint;
dhtmlBox.prototype.lastLinePaint = dhtmlBox_lastLinePaint; // draw the last straight vertex for the measure tool
dhtmlBox.prototype.changeTool = dhtmlBox_changetool;
dhtmlBox.prototype.removeEventsWait = dhtmlBox_removeEventsWait;

/*
function changeTool(dhtmlBox,tool) {
  dhtmlBox.changetool(tool);
}
*/

function dhtmlBox_removeEventsWait() {
   xRemoveEventListener(this.target, 'mousemove', this.domousemove);
   if (this.target.style) this.target.style.cursor = &quot;wait&quot;;
}


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000075.html">[Spip-carto-cvs] CVSROOT modules,1.5,1.6
</A></li>
	<LI>Next message: <A HREF="000078.html">[Spip-carto-cvs] spipcarto/ecrire/lang ecrire_ar.php3,NONE,1.1
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#77">[ date ]</a>
              <a href="thread.html#77">[ thread ]</a>
              <a href="subject.html#77">[ subject ]</a>
              <a href="author.html#77">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/spip-carto-cvs">More information about the Spip-carto-cvs
mailing list</a><br>
</body></html>
